

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Implementation &mdash; Detcap 2.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=51b770b3"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Troubleshooting" href="troubleshooting.html" />
    <link rel="prev" title="User Interface" href="ui.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Detcap
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="operation.html">Operation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ui.html">User Interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Implementation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#channel-selection-and-inventory">Channel selection and inventory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-acquisition">Data acquisition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trace-processing">Trace processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#latency">Latency</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amplitude">Amplitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-of-mla-amplitude">Simulation of mla amplitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-of-mb-amplitude">Simulation of mb amplitude</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#calculating-the-map">Calculating the map</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#amplitude-for-mla">Amplitude for mla</a></li>
<li class="toctree-l3"><a class="reference internal" href="#amplitude-for-mb">Amplitude for mb</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calculating-magnitude">Calculating magnitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="#attenuation-for-mla">Attenuation for mla</a></li>
<li class="toctree-l3"><a class="reference internal" href="#attenuation-for-mb">Attenuation for mb</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-to-detection">Time-to-detection</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting.html">Troubleshooting</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Detcap</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Implementation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/implementation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="implementation">
<h1>Implementation<a class="headerlink" href="#implementation" title="Link to this heading"></a></h1>
<p>This sections goes into detail about the algorithms and data used
by detcap.</p>
<section id="channel-selection-and-inventory">
<h2>Channel selection and inventory<a class="headerlink" href="#channel-selection-and-inventory" title="Link to this heading"></a></h2>
<p>The first step of the processing pipeline is to sort out the stations
and channels being used.</p>
<p>Detcap works by fetching every station possible from the inventory
(either provided by the user or taken from an FDSN server). The stations
considered are based on:</p>
<ul class="simple">
<li><p>filtering provided by the user (excluding/including station and/or
network codes)</p></li>
<li><p>some base filtering that excludes e.g. metadata channels</p></li>
<li><p>the channel properties required by the magnitude metric</p></li>
<li><p>whether required metadata is available in the inventory</p></li>
</ul>
<p>For user filtering, see <a class="reference internal" href="operation.html#station-filtering"><span class="std std-ref">Blacklisting and Whitelisting</span></a>.</p>
<p>The base filtering is part of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">detcap.settings</span></code> module.
Currently this only allows channels matching: [B|H|S] [H|L] [Z|N|E|1|2].
In English: only broadband, high broadband, short period bands,
high gain, low gain seismometers and north, south, east, west and
vertical oriented channels are considered.</p>
<p>The channel properties is an interal mechanism ensuring we only
calculate on the channels compatible with the magnitude. For both
mla and mb, this restricts the channels used to vertical orientation.</p>
<p>The metadata required from the inventory:</p>
<ul class="simple">
<li><p>A velocity (m/s) PAZ response, including gain and sensitivity</p></li>
<li><p>A latitude and longitude (the coordinate is taken from the station
and used for all channels)</p></li>
<li><p>A sample rate</p></li>
</ul>
<p>Channels missing any of this metadata are not considered.</p>
</section>
<section id="data-acquisition">
<h2>Data acquisition<a class="headerlink" href="#data-acquisition" title="Link to this heading"></a></h2>
<p>We can then proceed to start receiving data via Seedlink for each
used channel.</p>
<p>When a waveform arrives (I use the term “packet” and “trace” interchangably
from here on to refer to a block of data received from Seedlink), the
arrival time is recorded and the packet data is stored.</p>
<p>This continues until an update is triggered, currently hardcoded
to every 60 seconds.</p>
</section>
<section id="trace-processing">
<h2>Trace processing<a class="headerlink" href="#trace-processing" title="Link to this heading"></a></h2>
<p>When the update is triggered, the collected packets are “handled”.
This involves taking a 20 second window of data, starting from the time
of the last update, so the time window covers:</p>
<div class="math notranslate nohighlight">
\[(now - 60s)\ to\ (now - 40s)\]</div>
<p>I refer to this time window as the “long-term average” or LTA. As in,
we are performing our calculations on a long-term average of 20 seconds
of station data.</p>
<p>This 20 second slice is taken for each channel.</p>
<section id="latency">
<h3>Latency<a class="headerlink" href="#latency" title="Link to this heading"></a></h3>
<p>For latency measurements, we subtract the arrival time of each packet
(when we got it) from the start time of the packet’s measuring window.</p>
<figure class="align-center" id="id35">
<img alt="_images/latency_diagram.png" src="_images/latency_diagram.png" />
<figcaption>
<p><span class="caption-text">Visual representation of latency calculation.</span><a class="headerlink" href="#id35" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>We store these values for later processing. This measurement accounts
for both network latency, and the length of the measuring window
(assuming a worst case scenario of a meaningful signal occurring at
the end of a measurement).</p>
<p>This accounts for backfilled packets by increasing the overall latecy.
E.g. if a packet was recorded 10 minutes ago but we’re only seeing it now,
then 10 minutes + the length of the measurement window is added to that
channel’s collection of latency measurements.</p>
</section>
<section id="amplitude">
<h3>Amplitude<a class="headerlink" href="#amplitude" title="Link to this heading"></a></h3>
<p>For each trace, we simulate it as being observed on either a Wood-Anderson
seismometer (for mla) or a World-Wide Standardized Seismograph Network
Short-Period (WWSSN SP) seismometer (for mb). We store the simulated
trace values for later processing. Both types of amplitude are output
as displacement in meters.</p>
</section>
<section id="simulation-of-mla-amplitude">
<h3>Simulation of mla amplitude<a class="headerlink" href="#simulation-of-mla-amplitude" title="Link to this heading"></a></h3>
<p>For mla, the seismometer simulation comes from the accepeted method
of processing amplitudes for local magnitudes. This can be found written
by IASPEI <a class="footnote-reference brackets" href="#id21" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> under “Standard Procedures for Widely Used Magnitude Types”.</p>
<p>It also follows SeisComP’s method: we can see in our custom mla plugin <a class="footnote-reference brackets" href="#id22" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>
that we use Seiscomp’s MLv amplitude processor <a class="footnote-reference brackets" href="#id23" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> to calculate mla
amplitude. The MLv processor itself is a wrapper around the
ML amplitude processor <a class="footnote-reference brackets" href="#id24" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>, which simulates the amplitude as Wood-Anderson.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>I’m unsure about the correction required for calculating ML amplitude
on a vertical component. The IASPEI paper specifies
<cite>ML = log10(A) + C(R) + D</cite>, where <cite>C(R)</cite> and <cite>D</cite>
“have been calibrated… to adjust… between amplitudes measured on
horizontal seismographs and thsoe measured on vertical seismographs”</p>
<p>The calibration term for the regional difference is handled by
the MLa formula, but I haven’t considered the horizontal to vertical
calibration. SeisComP handles this by multiplying the result
of the ML amplitude by 2. I should implement this solely because
it’s what SeisComP does.</p>
</div>
<p>The poles and zeros used for Wood-Anderson:</p>
<blockquote>
<div><ul class="simple">
<li><p>Poles: [-6.283 + 4.7124j, -6.283 + -4.7124]</p></li>
<li><p>Zeros: [0 + 0j]</p></li>
<li><p>Gain: 1.0</p></li>
<li><p>Sensitivity: 2080</p></li>
</ul>
</div></blockquote>
<p>These values come from Obspy <a class="footnote-reference brackets" href="#id25" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. These differ from those used by IASPEI <a class="footnote-reference brackets" href="#id21" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
and SeisComP <a class="footnote-reference brackets" href="#id26" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>. Because Obspy has a documented interface with examples
of doing this simulation, I ended up using these values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is something I could use help on. In the IASPEI paper,
along with the poles and zeros they also specify “seismometer free period”,
and “seismometer damping constant”. I don’t know how these factor into
the simulation, and aren’t used by Obspy. Obspy also uses gain and sensitivity,
which IASPEI doesn’t specify. Alternatives to processing are to implement
SeisComP’s method or use something like SAC. So in general I’m sort of
lost when it comes to performing these simulations.</p>
</div>
<p>The simulation is done using Obspy’s <code class="docutils literal notranslate"><span class="pre">simulate_seismometer</span></code> <a class="footnote-reference brackets" href="#id27" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.
Before simulation, the trace is detrended and run through a 0.2-7Hz 3-corner
bandpass filter. We then perform the simulation with a <code class="docutils literal notranslate"><span class="pre">water_level</span></code> of 60 <a class="footnote-reference brackets" href="#id28" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="simulation-of-mb-amplitude">
<h3>Simulation of mb amplitude<a class="headerlink" href="#simulation-of-mb-amplitude" title="Link to this heading"></a></h3>
<p>We simulate as WWSSN SP according to IASPEI <a class="footnote-reference brackets" href="#id21" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. Poles and zeros used
are the same as specified by SeisComP <a class="footnote-reference brackets" href="#id29" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>9<span class="fn-bracket">]</span></a> and IASPEI <a class="footnote-reference brackets" href="#id21" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Poles: [-3.725 + -6.22j, -3.725 + 6.22j, -5.612 + 0j, -13.24 + 0j, -21.08 + 0j]</p></li>
<li><p>Zeros: [0 + 0j, 0 + 0j, 0 + 0j]</p></li>
<li><p>Gain: 532.14</p></li>
</ul>
</div></blockquote>
<p>The simulation is done using the same filtering and water level as used
for mla.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Again, unsure of this stuff. IASPEI once again specifie some
extra terms that don’t seem to be used, and don’t specify gain,
which SeisComP does. Also, what the hell is seismometer magnification?</p>
</div>
</section>
</section>
<section id="calculating-the-map">
<h2>Calculating the map<a class="headerlink" href="#calculating-the-map" title="Link to this heading"></a></h2>
<p>We now have data stores for each channel containing 20 seconds of latency
measurements and traces simulated as the required seismometer for the
magnitude type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the number of samples in the 20 second window is less than
the channel’s sample rate * 20 seconds, then it’s considered
to not have enough data for caluclating on and is skipped. This
could be refined, as it may be acceptable to calculate on partial
data.</p>
</div>
<p>The first step is reducing the 20 second value stores for each channel
to an aggregate value (the “LTA” for that channel).</p>
<section id="amplitude-for-mla">
<h3>Amplitude for mla<a class="headerlink" href="#amplitude-for-mla" title="Link to this heading"></a></h3>
<p>For mla amplitude, we convert the amplitude to millimeters and take
the average of the peak amplitudes of the trace. “Peak amplitude” here
means 1/2 the peak-to-trough amplitude, where peaks/troughs are separated
by a zero-crossing.</p>
<figure class="align-center" id="id36">
<img alt="_images/peaks.png" src="_images/peaks.png" />
<figcaption>
<p><span class="caption-text">A plot of the output of the peak finding algorithm. “Peak amplitude”
is 1/2 of a peak + its adjacent trough.</span><a class="headerlink" href="#id36" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>This is based on <a class="footnote-reference brackets" href="#id21" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>:
amplitudes used are “one-half the maximum deflection of the seismogram trace,
peak-to-adjacent-trough or trough-to-adjacent-peak”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Another point of debate: what IASPEI means is to take the maximum
of the peak amplitudes in the trace for use as <cite>A</cite> in magnitude
formulas. In this case we’re taking the peak amplitudes of the
entire 20 seconds and taking the average in an attempt to get an
“average amplitude” over that time period. Would it make more
sense to just take the maximum?</p>
</div>
</section>
<section id="amplitude-for-mb">
<h3>Amplitude for mb<a class="headerlink" href="#amplitude-for-mb" title="Link to this heading"></a></h3>
<p>mb follows a similar process of measuring the average peak-to-peak,
but with some more steps. First the amplitudes are convered to
micrometers (see <a class="reference internal" href="#mb-attenuation"><span class="std std-ref">Attenuation for mb</span></a>). The amplitude for the mb
formula is used as <cite>A/T</cite>; the amplitude over its period (to a maximum of
3 seconds) <a class="footnote-reference brackets" href="#id21" id="id14" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
<p>To achieve this, we use SeisComP’s method <a class="footnote-reference brackets" href="#id30" id="id15" role="doc-noteref"><span class="fn-bracket">[</span>10<span class="fn-bracket">]</span></a>. We want the peaks of <cite>A/T</cite>;
the peaks must be calculated proportional to time, so we find the position
of the peaks in the derivative of the displacement trace, i.e. we are finding
the velocity peaks.</p>
<p>We then use these peak positions in the original displacement trace to get the
displacement amplitude where the peak <cite>A/T</cite> is located.</p>
<p>We again take 1/2 of each peak + its adjacent trough in the displacement trace.</p>
<p>We also record the period for each of these peak values, taken as
“twice the time-intervals separating the peak and adjacent-trough from which
the amplitudes are measured” <a class="footnote-reference brackets" href="#id21" id="id16" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. The formula for this is:</p>
<div class="math notranslate nohighlight">
\[T = 2 * ((curr - prev) / sample rate)\]</div>
<p>Where <cite>curr</cite> is the position of the current peak/trough and <cite>prev</cite> is the position
of the previous peak/trough.
In other words,  we’re calculating the number of samples between peak and trough and dividing this by
sample rate to get the period in seconds. This is again taken in the displacement trace,
but using the positions of the peak <cite>A/T</cite> found in its derivative.</p>
<p>When then divide each peak amplitude by its corresponding period and take the average of all these
values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Same thing again regarding average vs maximum.</p>
</div>
</section>
<section id="calculating-magnitude">
<h3>Calculating magnitude<a class="headerlink" href="#calculating-magnitude" title="Link to this heading"></a></h3>
<p>Hopefully this has made sense so far: for every channel we are monitoring,
we now have a 20 second average of the peak amplitudes, calculated in the
nessecary way for use with its respective magnitude formula.</p>
<p>Now we turn this into a magnitude, and put it in a geospatial context
by associating it with a coordinate using attenuation.</p>
<p>For each station, we take the “best” 20 second average
amplitude of its channels - “best” being the lowest amplitude.
The logic here being that the channel with the “best” or least noisey signal
would be able to detect smaller events.</p>
<p>We then iterate through all coordinates (these are centers of our
<cite>resolution</cite> x <cite>resolution</cite> grid cells). For each coordinate, we iterate
through the stations, sorted from closest to furthest (we prioritise
the closest stations). We calculate the magnitude the station could see at
this coordinate:</p>
<div class="math notranslate nohighlight">
\[magnitude = log10(lta * snr) + attenuation\]</div>
<p>Where <cite>lta</cite> is the 20 second average amplitude, and <cite>snr</cite> is the
signal-to-noise (SNR) ratio required for a detection. Currently the SNR
is set as 3. The rationale here is that for an event to be detected,
it would need to be <cite>snr</cite> times greater than the signal currently
observed by the station.</p>
<p>This probably gets as close as possible to the idea of detcap:
<cite>We treat whatever signal currently seen by the station as noise. By
applying SNR to that signal, we can calculate the magnitude of a hypothetical
signal that would be detected despite that noise</cite>.</p>
<p>Once we have calculated this value for <cite>n</cite> stations (the number of stations
required to detect an event reliably, e.g. 6 for mla), we take the <cite>nth</cite>
highest magnitude and set this as the detectable magnitude for that
coordinate. The logic being that this <cite>nth</cite> station is the weakest link
and we’re unable to perform better than this station if <cite>n</cite> stations
are required.</p>
<p>If there aren’t enough stations with valid data to fulfill the <cite>n</cite>
stations requirement, the detectable magnitude is set as <cite>nan</cite> (we can’t
detect anything at this coordinate).</p>
</section>
<section id="attenuation-for-mla">
<h3>Attenuation for mla<a class="headerlink" href="#attenuation-for-mla" title="Link to this heading"></a></h3>
<p>The attenuation formulas for mla are as follows:</p>
<p>Western Australia:</p>
<div class="math notranslate nohighlight">
\[1.137 * log10(d) + (0.000657 * d) + 0.66\]</div>
<p>Eastern Australia:</p>
<div class="math notranslate nohighlight">
\[1.34 * log10(d / 100.0) + 0.00055 * (d - 100.0) + 3.13\]</div>
<p>Southern Australia (Flinders Ranges):</p>
<div class="math notranslate nohighlight">
\[1.1 * log10(d) + (0.0013 * d) + 0.7\]</div>
<p>Where <cite>d</cite> is the distance in degrees from the coordinate to the station.</p>
<p>At the start of processing, we check which region of the mla polygon
each coordinate of the map falls into. This determines which function
is used to calculate the attenuation for that coordinate.</p>
<p>Note that any coordinates outside the mla polygon are disregarded.</p>
</section>
<section id="attenuation-for-mb">
<span id="mb-attenuation"></span><h3>Attenuation for mb<a class="headerlink" href="#attenuation-for-mb" title="Link to this heading"></a></h3>
<p>This applies the <cite>q</cite> attenuation value, based on the distance
from the station to the coordinate. I’ve made some assumptions on my
part, as there are multiple choices of <cite>q</cite> values:</p>
<ul class="simple">
<li><p>the original Richter-Gutenberg function, intended for use with amplitudes
in micrometres, considered superceded.</p></li>
<li><p>a version of Richter-Gutenberg intended for use with nanometres, as part
of “The new IASPEI standards”, accompanied by a -3 correction term.
Used by NEIC.</p></li>
<li><p>Veith-Clawson. I’m assuming intended for use with nanometres given it’s
lower values compared to factors intended for micrometres,
but I was never able to confirm.</p></li>
<li><p>SeisComP’s, credited to Saul &amp; Bormann 2007 <a class="footnote-reference brackets" href="#id31" id="id17" role="doc-noteref"><span class="fn-bracket">[</span>11<span class="fn-bracket">]</span></a>.</p></li>
</ul>
<p>Detcap uses SeisComp’s method, with some assumptions. I believe these
<cite>q</cite> values have been calibrated for use with amplitudes in micrometers.
This is based on:</p>
<ul class="simple">
<li><p>SeisComP convering the amplitudes to micrometers before calculating
mb <a class="footnote-reference brackets" href="#id32" id="id18" role="doc-noteref"><span class="fn-bracket">[</span>12<span class="fn-bracket">]</span></a>.</p></li>
<li><p>SeisComP’s lack of -3 correction term, used with the NEIC method which
is intended for use with nanometers.</p></li>
</ul>
<p>What makes me wary about my assumptions is that Gempa states on the
SeisComP website <a class="footnote-reference brackets" href="#id33" id="id19" role="doc-noteref"><span class="fn-bracket">[</span>13<span class="fn-bracket">]</span></a> that mb amplitude is in micrometers, but they also
apply the -3 correction. This correction doesn’t happen in their code.
When I use SeisComP’s <cite>q</cite> and apply the -3 correction, the resulting
magnitudes seem too low (e.g. 4mb without correction will become ~1mb).
I’m chalking this up to a discrepancy between their code and documentation.</p>
<p>With these assumptions in mind, the SeisComP <cite>q</cite> table is used, and we
also use their code for interpolating inbetween the values <a class="footnote-reference brackets" href="#id34" id="id20" role="doc-noteref"><span class="fn-bracket">[</span>14<span class="fn-bracket">]</span></a>.</p>
</section>
<section id="time-to-detection">
<h3>Time-to-detection<a class="headerlink" href="#time-to-detection" title="Link to this heading"></a></h3>
<p>Once we have the <cite>n</cite> stations used in calculating the magnitudes, we
take the avearge of the previously recorded latencies for each station
and add the AK-135 P-phase travel time from that station to the coordinate:</p>
<div class="math notranslate nohighlight">
\[ttd = station\ latency + travel\ time\]</div>
<p>The worst (slowest) of these values amongst the <cite>n</cite> is then chosen as
the time-to-detection for the coordinate. The rationale being that
a signal must reach all <cite>n</cite> stations to be detected, so the fastest
we can detect the signal-generating event is limited by the slowest
station latency + travel time.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id21" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id10">3</a>,<a role="doc-backlink" href="#id12">4</a>,<a role="doc-backlink" href="#id13">5</a>,<a role="doc-backlink" href="#id14">6</a>,<a role="doc-backlink" href="#id16">7</a>)</span>
<p><a class="reference external" href="http://iaspei.org/commissions/commission-on-seismological-observation-and-interpretation/Summary_WG_recommendations_20130327.pdf">IASPEI Working Group Recommendations</a></p>
</aside>
<aside class="footnote brackets" id="id22" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/GeoscienceAustralia/ga-mla/blob/6d2b3fa5375bccf09a459bcac65426665bb7b826/plugins/magnitudes/mla/mla.cpp#L93">Geoscience Australia mla SeisComP module</a></p>
</aside>
<aside class="footnote brackets" id="id23" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/master/libs/seiscomp/processing/amplitudes/MLv.cpp">SeisComP MLv amplitude processor</a></p>
</aside>
<aside class="footnote brackets" id="id24" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/447c13d0150e5965684bc36450b252a88b356213/libs/seiscomp/processing/amplitudes/ML.cpp#L140">SeisComP ML amplitude processor</a></p>
</aside>
<aside class="footnote brackets" id="id25" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/obspy/obspy/blob/71cb8dfda4650935c244335af452eff4eb8db8b9/obspy/signal/invsim.py#L44">Wood-Anderson PAZ according to Obspy</a></p>
</aside>
<aside class="footnote brackets" id="id26" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/bb54cd5488636f7edac024ab18ff100a2dd0d21f/libs/seiscomp/math/filter/seismometers.cpp#L47">Wood-Anderson PAZ according to SeisComP</a></p>
</aside>
<aside class="footnote brackets" id="id27" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.obspy.org/packages/autogen/obspy.signal.invsim.simulate_seismometer.html">Obspy’s simulate_seismometer</a></p>
</aside>
<aside class="footnote brackets" id="id28" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id9">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/obspy/obspy/issues/1594#issuecomment-262232681">Note on water level</a></p>
</aside>
<aside class="footnote brackets" id="id29" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id11">9</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/bb54cd5488636f7edac024ab18ff100a2dd0d21f/libs/seiscomp/math/filter/seismometers.cpp#L392">WWSSN SP PAZ according to SeisComP</a></p>
</aside>
<aside class="footnote brackets" id="id30" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">10</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/5f7cd281fb2994fe782edc184f1e2343483aef36/libs/seiscomp/processing/amplitudes/mb.cpp#L176">Finding A/T peaks</a></p>
</aside>
<aside class="footnote brackets" id="id31" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">11</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/5f7cd281fb2994fe782edc184f1e2343483aef36/libs/seiscomp/seismology/mb.cpp#L57">SeisComP’s q table</a></p>
</aside>
<aside class="footnote brackets" id="id32" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">12</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/5f7cd281fb2994fe782edc184f1e2343483aef36/libs/seiscomp/processing/magnitudes/mb.cpp#L114">SeisComP convering to micrometers</a></p>
</aside>
<aside class="footnote brackets" id="id33" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">13</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.seiscomp.de/doc/apps/global_mb.html">SeisComP’s published mb formula</a></p>
</aside>
<aside class="footnote brackets" id="id34" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">14</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/SeisComP/common/blob/5f7cd281fb2994fe782edc184f1e2343483aef36/libs/seiscomp/seismology/mb.cpp#L116">SeisComP method for determining q</a></p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ui.html" class="btn btn-neutral float-left" title="User Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="troubleshooting.html" class="btn btn-neutral float-right" title="Troubleshooting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Geoscience Australia.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>